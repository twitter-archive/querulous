package com.twitter.querulous.test.sql

import java.sql._

class FakeStatement(
  private[this] val conn: Connection,
  private[this] var resultSetType: Int,
  private[this] var resultSetConcurrency: Int
  ) extends Statement {

  private[this] var open: Boolean = true
  private[this] var maxFieldSize: Int = 1024
  private[this] var maxRows: Int = 1024
  private[this] var escapeProcessing: Boolean = false
  private[this] var queryTimeout: Int = 1000
  private[this] var cursorName: String = ""
  private[this] var fetchDirection: Int = 1
  private[this] var fetchSize: Int = 1

  def this(conn: Connection) = {
    this(conn, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)
  }

  @throws(classOf[SQLException])
  def executeQuery(sql: String): ResultSet = {
    checkOpen()
    null
  }

  @throws(classOf[SQLException])
  def executeUpdate(sql: String): Int = {
    checkOpen()
    1
  }

  @throws(classOf[SQLException])
  def close() {
    open = false
  }

  @throws(classOf[SQLException])
  def getMaxFieldSize: Int = {
    checkOpen()
    maxFieldSize
  }

  @throws(classOf[SQLException])
  def setMaxFieldSize(maxFieldSize: Int) {
    checkOpen()
    this.maxFieldSize = maxFieldSize
  }

  @throws(classOf[SQLException])
  def getMaxRows: Int = {
    checkOpen()
    this.maxRows
  }

  @throws(classOf[SQLException])
  def setMaxRows(maxRows: Int) {
    checkOpen()
    this.maxRows = maxRows
  }

  @throws(classOf[SQLException])
  def setEscapeProcessing(enable: Boolean) {
     checkOpen()
     this.escapeProcessing = enable
  }

  @throws(classOf[SQLException])
  def getQueryTimeout: Int = {
    checkOpen()
    this.queryTimeout
  }

  @throws(classOf[SQLException])
  def setQueryTimeout(numSecs: Int) {
    checkOpen()
    this.queryTimeout = numSecs
  }

  @throws(classOf[SQLException])
  def cancel() {
    checkOpen()
  }

  @throws(classOf[SQLException])
  def getWarnings: SQLWarning = {
    checkOpen()
    null
  }

  @throws(classOf[SQLException])
  def clearWarnings() {
    checkOpen()
  }

  @throws(classOf[SQLException])
  def setCursorName(name: String) {
    checkOpen()
    this.cursorName = name
  }

  @throws(classOf[SQLException])
  def execute(sql: String): Boolean = {
    checkOpen()
    true
  }

  @throws(classOf[SQLException])
  def getResultSet: ResultSet = {
    checkOpen()
    null
  }

  @throws(classOf[SQLException])
  def getUpdateCount: Int = {
    checkOpen()
    1
  }

  @throws(classOf[SQLException])
  def getMoreResults: Boolean = {
    checkOpen()
    false
  }

  @throws(classOf[SQLException])
  def setFetchDirection(direction: Int) {
    checkOpen();
    this.fetchDirection = direction;
  }

  @throws(classOf[SQLException])
  def getFetchDirection: Int = {
    checkOpen()
    this.fetchDirection;
  }

  @throws(classOf[SQLException])
  def setFetchSize(rows: Int) {
    checkOpen()
    this.fetchSize = rows
  }

  @throws(classOf[SQLException])
  def getFetchSize: Int = {
    checkOpen()
    this.fetchSize
  }

  @throws(classOf[SQLException])
  def getResultSetConcurrency: Int = {
    checkOpen()
    this.resultSetConcurrency
  }

  @throws(classOf[SQLException])
  def getResultSetType: Int = {
    checkOpen()
    this.resultSetType
  }

  @throws(classOf[SQLException])
  def addBatch(sql: String) {
    checkOpen()
  }

  @throws(classOf[SQLException])
  def clearBatch() {
    checkOpen()
  }

  @throws(classOf[SQLException])
  def executeBatch(): scala.Array[Int] = {
    checkOpen()
    new scala.Array[Int](0);
  }

  @throws(classOf[SQLException])
  def getConnection: Connection = {
    checkOpen()
    this.conn
  }

  @throws(classOf[SQLException])
  def getMoreResults(current: Int): Boolean = {
    throw new SQLException("Not implemented");
  }

  @throws(classOf[SQLException])
  def getGeneratedKeys: ResultSet = {
    null
  }

  @throws(classOf[SQLException])
  def executeUpdate(sql: String, autoGeneratedKeys: Int): Int = {
    throw new SQLException("Not implemented")
  }

  @throws(classOf[SQLException])
  def executeUpdate(sql: String, columnIndexes: scala.Array[Int]): Int = {
    throw new SQLException("Not implemented")
  }

  @throws(classOf[SQLException])
  def executeUpdate(sql: String, columnNames: scala.Array[String]): Int = {
    throw new SQLException("Not implemented")
  }

  @throws(classOf[SQLException])
  def execute(sql: String, autoGeneratedKeys: Int): Boolean = {
    throw new SQLException("Not implemented")
  }

  @throws(classOf[SQLException])
  def execute(sql: String, columnIndexes: scala.Array[Int]): Boolean = {
    throw new SQLException("Not implemented")
  }

  @throws(classOf[SQLException])
  def execute(sql: String, columnNames: scala.Array[String]): Boolean = {
    throw new SQLException("Not implemented")
  }

  @throws(classOf[SQLException])
  def getResultSetHoldability: Int = {
    checkOpen()
    throw new SQLException("Not implemented")
  }

  @throws(classOf[SQLException])
  def isWrapperFor(iface: Class[_]): Boolean = {
    throw new SQLException("Not implemented")
  }

  @throws(classOf[SQLException])
  def unwrap[T](iface: Class[T]): T = {
    throw new SQLException("Not implemented");
  }

  @throws(classOf[SQLException])
  def isClosed: Boolean = {
    !this.open
  }

  @throws(classOf[SQLException])
  def setPoolable(poolable: Boolean) {
    throw new SQLException("Not implemented")
  }

  @throws(classOf[SQLException])
  def isPoolable: Boolean = {
    throw new SQLException("Not implemented");
  }

  @throws(classOf[SQLException])
  protected[sql] def checkOpen() {
    FakeConnection.isDown(conn.asInstanceOf[FakeConnection])

    if (!this.open) {
      throw new SQLException("Statement is closed")
    }

    if(conn.isClosed) {
      throw new SQLException("Connection is closed");
    }
  }
}
